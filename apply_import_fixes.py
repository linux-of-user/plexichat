#!/usr/bin/env python3
"""
Apply Import Fixes Script for PlexiChat

This script applies the import fixes generated by import_verification.py
to systematically update all import statements to use proper src.plexichat paths.
"""

import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Set

def apply_fixes_to_file(file_path: str, file_fixes: List[Dict]) -> bool:
    """Apply all fixes to a single file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        lines = content.splitlines()
        
        # Sort fixes by line number in descending order to avoid index issues
        sorted_fixes = sorted(file_fixes, key=lambda x: x['line'], reverse=True)
        
        changes_made = 0
        for fix in sorted_fixes:
            line_idx = fix['line'] - 1  # Convert to 0-based index
            
            if line_idx < 0 or line_idx >= len(lines):
                print(f"  Warning: Line {fix['line']} out of range in {file_path}")
                continue
            
            old_line = lines[line_idx].strip()
            
            # Try exact match first
            if old_line == fix['old'].strip():
                lines[line_idx] = lines[line_idx].replace(fix['old'], fix['new'])
                changes_made += 1
            else:
                # Try partial match - look for the import statement pattern
                if fix['old'].strip() in old_line:
                    lines[line_idx] = lines[line_idx].replace(fix['old'], fix['new'])
                    changes_made += 1
                else:
                    print(f"  Warning: Could not find exact match for line {fix['line']} in {file_path}")
                    print(f"    Expected: {fix['old']}")
                    print(f"    Found:    {old_line}")
        
        if changes_made > 0:
            # Write the updated content back
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write('\n'.join(lines))
                if content.endswith('\n'):  # Preserve trailing newline if it existed
                    f.write('\n')
            
            print(f"  Applied {changes_made} fixes to {file_path}")
            return True
        else:
            print(f"  No changes made to {file_path}")
            return False
            
    except Exception as e:
        print(f"  Error processing {file_path}: {e}")
        return False

def load_fixes(fixes_file: str) -> Dict[str, List[Dict]]:
    """Load fixes from JSON file and group by file."""
    try:
        with open(fixes_file, 'r') as f:
            fixes = json.load(f)
        
        fixes_by_file = {}
        for fix in fixes:
            file_path = fix['file']
            if file_path not in fixes_by_file:
                fixes_by_file[file_path] = []
            fixes_by_file[file_path].append(fix)
        
        return fixes_by_file
        
    except Exception as e:
        print(f"Error loading fixes file: {e}")
        return {}

def backup_files(file_paths: Set[str], backup_dir: str = "import_fixes_backup") -> bool:
    """Create backups of files before applying fixes."""
    try:
        backup_path = Path(backup_dir)
        backup_path.mkdir(exist_ok=True)
        
        for file_path in file_paths:
            if not os.path.exists(file_path):
                continue
                
            # Create the backup directory structure
            rel_path = Path(file_path)
            backup_file_path = backup_path / rel_path
            backup_file_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Copy the file
            import shutil
            shutil.copy2(file_path, backup_file_path)
        
        print(f"Created backups in {backup_dir}/")
        return True
        
    except Exception as e:
        print(f"Error creating backups: {e}")
        return False

def validate_fixes(fixes_by_file: Dict[str, List[Dict]]) -> bool:
    """Validate that all files exist and fixes look reasonable."""
    issues = []
    
    for file_path, fixes in fixes_by_file.items():
        if not os.path.exists(file_path):
            issues.append(f"File does not exist: {file_path}")
            continue
        
        # Check for reasonable fix patterns
        for fix in fixes:
            old = fix.get('old', '')
            new = fix.get('new', '')
            
            if not old or not new:
                issues.append(f"Empty import in {file_path}: '{old}' -> '{new}'")
            
            if old == new:
                issues.append(f"No-op fix in {file_path}: '{old}'")
            
            # Ensure we're adding src.plexichat
            if 'src.plexichat' not in new:
                issues.append(f"Fix doesn't add src.plexichat in {file_path}: '{old}' -> '{new}'")
    
    if issues:
        print("Validation issues found:")
        for issue in issues[:10]:  # Show first 10 issues
            print(f"  {issue}")
        if len(issues) > 10:
            print(f"  ... and {len(issues) - 10} more")
        return False
    
    return True

def main():
    """Main function."""
    fixes_file = "import_fixes.json"
    
    if not os.path.exists(fixes_file):
        print(f"Error: {fixes_file} not found. Run import_verification.py first.")
        return 1
    
    print("Loading import fixes...")
    fixes_by_file = load_fixes(fixes_file)
    
    if not fixes_by_file:
        print("No fixes to apply.")
        return 0
    
    print(f"Found fixes for {len(fixes_by_file)} files")
    
    # Validate fixes
    print("Validating fixes...")
    if not validate_fixes(fixes_by_file):
        print("Validation failed. Please review the fixes manually.")
        return 1
    
    # Get user confirmation
    total_fixes = sum(len(fixes) for fixes in fixes_by_file.values())
    print(f"\nReady to apply {total_fixes} fixes to {len(fixes_by_file)} files.")
    
    if len(sys.argv) > 1 and sys.argv[1] == "--auto":
        proceed = True
    else:
        response = input("Do you want to proceed? [y/N]: ")
        proceed = response.lower().startswith('y')
    
    if not proceed:
        print("Cancelled.")
        return 0
    
    # Create backups
    print("Creating backups...")
    if not backup_files(set(fixes_by_file.keys())):
        print("Failed to create backups. Aborting.")
        return 1
    
    # Apply fixes
    print("Applying fixes...")
    files_modified = 0
    total_changes = 0
    
    for file_path, file_fixes in fixes_by_file.items():
        if apply_fixes_to_file(file_path, file_fixes):
            files_modified += 1
        total_changes += len(file_fixes)
    
    print(f"\nCompleted! Modified {files_modified} files with {total_changes} import fixes.")
    print("Backups created in import_fixes_backup/")
    print("Run tests to verify everything still works correctly.")
    
    return 0

if __name__ == '__main__':
    sys.exit(main())