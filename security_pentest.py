#!/usr/bin/env python3
"""
PlexiChat Security Penetration Testing Suite

Comprehensive security testing including:
- Authentication bypass attempts
- Authorization and privilege escalation
- Input validation and injection attacks
- Rate limiting and DoS testing
- Session management vulnerabilities
- API security testing
"""

import requests
import json
import time
import random
import string
import threading
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin
import base64
import hashlib

class SecurityPenTest:
    """Comprehensive security penetration testing suite."""
    
    def __init__(self, base_url: str = "http://localhost:8006"):
        self.base_url = base_url
        self.session = requests.Session()
        self.results = []
        self.auth_token = None
        self.test_user_data = {
            "username": "testuser_" + ''.join(random.choices(string.ascii_lowercase, k=6)),
            "email": f"test_{random.randint(1000, 9999)}@example.com",
            "password": "TestPassword123!"
        }
        
    def log_result(self, test_name: str, status: str, details: str, risk_level: str = "INFO"):
        """Log test results."""
        result = {
            "test": test_name,
            "status": status,
            "details": details,
            "risk_level": risk_level,
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S")
        }
        self.results.append(result)
        
        # Color coding for console output
        colors = {
            "CRITICAL": "\033[91m",  # Red
            "HIGH": "\033[93m",      # Yellow
            "MEDIUM": "\033[94m",    # Blue
            "LOW": "\033[92m",       # Green
            "INFO": "\033[96m",      # Cyan
            "PASS": "\033[92m"       # Green
        }
        reset = "\033[0m"
        
        color = colors.get(risk_level, colors["INFO"])
        print(f"{color}[{risk_level}] {test_name}: {status}{reset}")
        print(f"  Details: {details}")
        print()
    
    def test_server_availability(self) -> bool:
        """Test if the server is available."""
        try:
            response = self.session.get(f"{self.base_url}/health", timeout=5)
            if response.status_code == 200:
                self.log_result("Server Availability", "PASS", f"Server responding on {self.base_url}", "INFO")
                return True
            else:
                self.log_result("Server Availability", "FAIL", f"Server returned {response.status_code}", "CRITICAL")
                return False
        except Exception as e:
            self.log_result("Server Availability", "FAIL", f"Cannot connect to server: {e}", "CRITICAL")
            return False
    
    def test_authentication_bypass(self):
        """Test authentication bypass vulnerabilities."""
        print("\n=== AUTHENTICATION BYPASS TESTING ===")
        
        # Test 1: False credentials
        false_credentials = [
            {"username": "admin", "password": "admin"},
            {"username": "admin", "password": "password"},
            {"username": "admin", "password": "123456"},
            {"username": "root", "password": "root"},
            {"username": "test", "password": "test"},
            {"username": "guest", "password": "guest"},
            {"username": "", "password": ""},
            {"username": "admin", "password": ""},
            {"username": "", "password": "admin"},
        ]
        
        for creds in false_credentials:
            try:
                response = self.session.post(
                    f"{self.base_url}/login/login/",
                    json=creds,
                    timeout=5
                )
                
                if response.status_code == 200:
                    try:
                        data = response.json()
                        if "token" in data or "access_token" in data:
                            self.log_result(
                                "Authentication Bypass",
                                "VULNERABLE",
                                f"Login succeeded with {creds['username']}:{creds['password']}",
                                "CRITICAL"
                            )
                        else:
                            self.log_result(
                                "Authentication Bypass",
                                "SECURE",
                                f"Login rejected for {creds['username']}:{creds['password']}",
                                "PASS"
                            )
                    except:
                        self.log_result(
                            "Authentication Bypass",
                            "SECURE",
                            f"Login rejected for {creds['username']}:{creds['password']}",
                            "PASS"
                        )
                else:
                    self.log_result(
                        "Authentication Bypass",
                        "SECURE",
                        f"Login properly rejected ({response.status_code}) for {creds['username']}:{creds['password']}",
                        "PASS"
                    )
            except Exception as e:
                self.log_result(
                    "Authentication Bypass",
                    "ERROR",
                    f"Error testing {creds['username']}:{creds['password']} - {e}",
                    "MEDIUM"
                )
    
    def test_sql_injection(self):
        """Test SQL injection vulnerabilities."""
        print("\n=== SQL INJECTION TESTING ===")
        
        sql_payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' OR 1=1#",
            "'; DROP TABLE users;--",
            "' UNION SELECT * FROM users--",
            "admin'--",
            "admin' OR '1'='1'--",
            "1' OR '1'='1",
            "' OR 'a'='a",
            "') OR ('1'='1",
        ]
        
        # Test login endpoints
        for payload in sql_payloads:
            try:
                response = self.session.post(
                    f"{self.base_url}/login/login/",
                    json={"username": payload, "password": "test"},
                    timeout=5
                )
                
                if response.status_code == 500:
                    self.log_result(
                        "SQL Injection",
                        "POTENTIALLY_VULNERABLE",
                        f"Server error (500) with payload: {payload}",
                        "HIGH"
                    )
                elif response.status_code == 200:
                    try:
                        data = response.json()
                        if "token" in data or "access_token" in data:
                            self.log_result(
                                "SQL Injection",
                                "VULNERABLE",
                                f"Authentication bypassed with SQL injection: {payload}",
                                "CRITICAL"
                            )
                    except:
                        pass
                else:
                    self.log_result(
                        "SQL Injection",
                        "SECURE",
                        f"SQL injection payload properly handled: {payload}",
                        "PASS"
                    )
            except Exception as e:
                self.log_result(
                    "SQL Injection",
                    "ERROR",
                    f"Error testing payload {payload}: {e}",
                    "MEDIUM"
                )
    
    def test_xss_vulnerabilities(self):
        """Test Cross-Site Scripting vulnerabilities."""
        print("\n=== XSS VULNERABILITY TESTING ===")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//",
            "<iframe src=javascript:alert('XSS')></iframe>",
            "<body onload=alert('XSS')>",
            "<input onfocus=alert('XSS') autofocus>",
        ]
        
        # Test various endpoints that might reflect user input
        test_endpoints = [
            "/login/login/",
            "/users/users/",
            "/messages/messages/send",
        ]
        
        for endpoint in test_endpoints:
            for payload in xss_payloads:
                try:
                    # Test in different fields
                    test_data = {
                        "username": payload,
                        "password": "test",
                        "content": payload,
                        "message": payload,
                        "name": payload
                    }
                    
                    response = self.session.post(
                        f"{self.base_url}{endpoint}",
                        json=test_data,
                        timeout=5
                    )
                    
                    # Check if payload is reflected in response
                    if payload in response.text:
                        self.log_result(
                            "XSS Vulnerability",
                            "POTENTIALLY_VULNERABLE",
                            f"XSS payload reflected in {endpoint}: {payload}",
                            "HIGH"
                        )
                    else:
                        self.log_result(
                            "XSS Vulnerability",
                            "SECURE",
                            f"XSS payload properly sanitized in {endpoint}",
                            "PASS"
                        )
                        
                except Exception as e:
                    self.log_result(
                        "XSS Vulnerability",
                        "ERROR",
                        f"Error testing XSS in {endpoint}: {e}",
                        "MEDIUM"
                    )
    
    def test_rate_limiting(self):
        """Test rate limiting effectiveness."""
        print("\n=== RATE LIMITING TESTING ===")
        
        # Test rapid requests to login endpoint
        start_time = time.time()
        successful_requests = 0
        rate_limited_requests = 0
        
        for i in range(50):  # Send 50 rapid requests
            try:
                response = self.session.post(
                    f"{self.base_url}/login/login/",
                    json={"username": f"test{i}", "password": "test"},
                    timeout=2
                )
                
                if response.status_code == 429:  # Too Many Requests
                    rate_limited_requests += 1
                elif response.status_code in [200, 401, 403]:
                    successful_requests += 1
                    
            except Exception:
                pass
        
        end_time = time.time()
        duration = end_time - start_time
        
        if rate_limited_requests > 0:
            self.log_result(
                "Rate Limiting",
                "SECURE",
                f"Rate limiting active: {rate_limited_requests} requests blocked out of 50",
                "PASS"
            )
        else:
            self.log_result(
                "Rate Limiting",
                "VULNERABLE",
                f"No rate limiting detected: {successful_requests} requests processed in {duration:.2f}s",
                "MEDIUM"
            )
    
    def test_authorization_bypass(self):
        """Test authorization and privilege escalation."""
        print("\n=== AUTHORIZATION BYPASS TESTING ===")
        
        # Test accessing protected endpoints without authentication
        protected_endpoints = [
            "/users/users/",
            "/messages/messages/list",
            "/system/system/status",
            "/admin/admin/users",
            "/files/files/upload",
        ]
        
        for endpoint in protected_endpoints:
            try:
                response = self.session.get(f"{self.base_url}{endpoint}", timeout=5)
                
                if response.status_code == 200:
                    self.log_result(
                        "Authorization Bypass",
                        "VULNERABLE",
                        f"Protected endpoint accessible without auth: {endpoint}",
                        "HIGH"
                    )
                elif response.status_code in [401, 403]:
                    self.log_result(
                        "Authorization Bypass",
                        "SECURE",
                        f"Protected endpoint properly secured: {endpoint}",
                        "PASS"
                    )
                else:
                    self.log_result(
                        "Authorization Bypass",
                        "INFO",
                        f"Endpoint {endpoint} returned {response.status_code}",
                        "INFO"
                    )
                    
            except Exception as e:
                self.log_result(
                    "Authorization Bypass",
                    "ERROR",
                    f"Error testing {endpoint}: {e}",
                    "MEDIUM"
                )
    
    def run_comprehensive_test(self):
        """Run all security tests."""
        print("🔒 PLEXICHAT SECURITY PENETRATION TEST")
        print("=" * 50)
        
        if not self.test_server_availability():
            print("❌ Server not available. Cannot proceed with security testing.")
            return
        
        # Run all security tests
        self.test_authentication_bypass()
        self.test_sql_injection()
        self.test_xss_vulnerabilities()
        self.test_rate_limiting()
        self.test_authorization_bypass()
        
        # Generate summary report
        self.generate_summary_report()
    
    def generate_summary_report(self):
        """Generate comprehensive security report."""
        print("\n" + "=" * 60)
        print("🔒 SECURITY PENETRATION TEST SUMMARY REPORT")
        print("=" * 60)
        
        # Count results by risk level
        risk_counts = {}
        for result in self.results:
            risk = result["risk_level"]
            risk_counts[risk] = risk_counts.get(risk, 0) + 1
        
        print(f"\n📊 RESULTS SUMMARY:")
        print(f"  Total Tests: {len(self.results)}")
        for risk, count in sorted(risk_counts.items()):
            print(f"  {risk}: {count}")
        
        # Show critical and high risk findings
        critical_findings = [r for r in self.results if r["risk_level"] in ["CRITICAL", "HIGH"]]
        if critical_findings:
            print(f"\n🚨 CRITICAL & HIGH RISK FINDINGS ({len(critical_findings)}):")
            for finding in critical_findings:
                print(f"  [{finding['risk_level']}] {finding['test']}: {finding['details']}")
        else:
            print(f"\n✅ NO CRITICAL OR HIGH RISK VULNERABILITIES FOUND")
        
        # Security score
        total_tests = len([r for r in self.results if r["risk_level"] != "ERROR"])
        secure_tests = len([r for r in self.results if r["status"] == "SECURE" or r["risk_level"] == "PASS"])
        
        if total_tests > 0:
            security_score = (secure_tests / total_tests) * 100
            print(f"\n🎯 SECURITY SCORE: {security_score:.1f}% ({secure_tests}/{total_tests} tests passed)")
        
        print("\n" + "=" * 60)

def main():
    """Main execution function."""
    import sys
    
    # Check if custom URL provided
    base_url = sys.argv[1] if len(sys.argv) > 1 else "http://localhost:8006"
    
    print(f"🔒 Starting security penetration test against: {base_url}")
    
    # Create and run penetration test
    pentest = SecurityPenTest(base_url)
    pentest.run_comprehensive_test()
    
    # Save detailed results
    with open("security_pentest_results.json", "w") as f:
        json.dump(pentest.results, f, indent=2)
    
    print(f"\n📄 Detailed results saved to: security_pentest_results.json")

if __name__ == "__main__":
    main()
